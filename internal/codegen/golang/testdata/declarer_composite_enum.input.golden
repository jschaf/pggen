// SomeTableEnum represents the Postgres composite type "some_table_enum".
type SomeTableEnum struct {
	Foo DeviceType `json:"foo"`
}

// newDeviceTypeEnum creates a new pgtype.ValueTranscoder for the
// Postgres enum type 'device_type'.
func newDeviceTypeEnum() pgtype.ValueTranscoder {
	return pgtype.NewEnumType(
		"device_type",
		[]string{
			string(DeviceTypeIOS),
			string(DeviceTypeMobile),
		},
	)
}

// DeviceType represents the Postgres enum "device_type".
type DeviceType string

const (
	DeviceTypeIOS    DeviceType = "ios"
	DeviceTypeMobile DeviceType = "mobile"
)

func (d DeviceType) String() string { return string(d) }

// typeResolver looks up the pgtype.ValueTranscoder by Postgres type name.
type typeResolver struct {
	connInfo *pgtype.ConnInfo // types by Postgres type name
}

func newTypeResolver(types []pgtype.DataType) *typeResolver {
	ci := pgtype.NewConnInfo()
	for _, typ := range types {
		if txt, ok := typ.Value.(textPreferrer); ok && typ.OID != unknownOID {
			typ.Value = txt.ValueTranscoder
		}
		ci.RegisterDataType(typ)
	}
	return &typeResolver{connInfo: ci}
}

// findValue find the OID, and pgtype.ValueTranscoder for a Postgres type name.
func (tr *typeResolver) findValue(name string) (uint32, pgtype.ValueTranscoder, bool) {
	typ, ok := tr.connInfo.DataTypeForName(name)
	if !ok {
		return 0, nil, false
	}
	v := pgtype.NewValue(typ.Value)
	return typ.OID, v.(pgtype.ValueTranscoder), true
}

// setValue sets the value of a ValueTranscoder to a value that should always
// work and panics if it fails.
func (tr *typeResolver) setValue(vt pgtype.ValueTranscoder, val interface{}) pgtype.ValueTranscoder {
	if err := vt.Set(val); err != nil {
		panic(fmt.Sprintf("set ValueTranscoder %T to %+v: %s", vt, val, err))
	}
	return vt
}

type compositeField struct {
	name       string                 // name of the field
	typeName   string                 // Postgres type name
	defaultVal pgtype.ValueTranscoder // default value to use
}

func (tr *typeResolver) newCompositeValue(name string, fields ...compositeField) pgtype.ValueTranscoder {
	if _, val, ok := tr.findValue(name); ok {
		return val
	}
	fs := make([]pgtype.CompositeTypeField, len(fields))
	vals := make([]pgtype.ValueTranscoder, len(fields))
	isBinaryOk := true
	for i, field := range fields {
		oid, val, ok := tr.findValue(field.typeName)
		if !ok {
			oid = unknownOID
			val = field.defaultVal
		}
		isBinaryOk = isBinaryOk && oid != unknownOID
		fs[i] = pgtype.CompositeTypeField{Name: field.name, OID: oid}
		vals[i] = val
	}
	// Okay to ignore error because it's only thrown when the number of field
	// names does not equal the number of ValueTranscoders.
	typ, _ := pgtype.NewCompositeTypeValues(name, fs, vals)
	if !isBinaryOk {
		return textPreferrer{ValueTranscoder: typ, typeName: name}
	}
	return typ
}

func (tr *typeResolver) newArrayValue(name, elemName string, defaultVal func() pgtype.ValueTranscoder) pgtype.ValueTranscoder {
	if _, val, ok := tr.findValue(name); ok {
		return val
	}
	elemOID, elemVal, ok := tr.findValue(elemName)
	elemValFunc := func() pgtype.ValueTranscoder {
		return pgtype.NewValue(elemVal).(pgtype.ValueTranscoder)
	}
	if !ok {
		elemOID = unknownOID
		elemValFunc = defaultVal
	}
	typ := pgtype.NewArrayType(name, elemOID, elemValFunc)
	if elemOID == unknownOID {
		return textPreferrer{ValueTranscoder: typ, typeName: name}
	}
	return typ
}

// newSomeTableEnum creates a new pgtype.ValueTranscoder for the Postgres
// composite type 'some_table_enum'.
func (tr *typeResolver) newSomeTableEnum() pgtype.ValueTranscoder {
	return tr.newCompositeValue(
		"some_table_enum",
		compositeField{name: "foo", typeName: "some_table_enum", defaultVal: newDeviceTypeEnum()},
	)
}

// newSomeTableEnumInit creates an initialized pgtype.ValueTranscoder for the
// Postgres composite type 'some_table_enum' to encode query parameters.
func (tr *typeResolver) newSomeTableEnumInit(v SomeTableEnum) pgtype.ValueTranscoder {
	return tr.setValue(tr.newSomeTableEnum(), tr.newSomeTableEnumRaw(v))
}

// newSomeTableEnumRaw returns all composite fields for the Postgres composite
// type 'some_table_enum' as a slice of interface{} to encode query parameters.
func (tr *typeResolver) newSomeTableEnumRaw(v SomeTableEnum) []interface{} {
	return []interface{}{
		v.Foo,
	}
}